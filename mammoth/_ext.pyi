from typing import ClassVar, List, Optional, Tuple, TypeVar, Union, overload

import numpy as np
import numpy.typing as npt

class AreaSettings:
    area_type: str
    ghost_area: float
    def __init__(self, area_type: str = ..., ghost_area: float = ...) -> None: ...

class ColumnarSplittings:
    def __init__(self, *args, **kwargs) -> None: ...  # type: ignore
    @property
    def delta_R(self) -> npt.NDArray[np.float32]: ...
    @property
    def kt(self) -> npt.NDArray[np.float32]: ...
    @property
    def parent_index(self) -> npt.NDArray[np.float32]: ...
    @property
    def z(self) -> npt.NDArray[np.float32]: ...

class ColumnarSubjest:
    def __init__(self, *args, **kwargs) -> None: ...  # type: ignore
    @property
    def constituent_indices(self) -> List[List[int]]: ...
    @property
    def part_of_iterative_splitting(self) -> npt.NDArray[np.bool_]: ...
    @property
    def splitting_node_index(self) -> npt.NDArray[np.int64]: ...

class ConstituentSubtractionSettings:
    alpha: float
    r_max: float
    def __init__(self, r_max: float = ..., alpha: float = ...) -> None: ...

class JetSubstructureSplittings:
    def __init__(self, *args, **kwargs) -> None: ...  # type: ignore
    def splittings(self) -> ColumnarSplittings: ...
    def subjets(self) -> ColumnarSubjest: ...

class OutputWrapperDouble:
    def __init__(self, *args, **kwargs) -> None: ...  # type: ignore
    @property
    def constituent_indices(self) -> List[List[int]]: ...
    @property
    def jets(self) -> Tuple[npt.NDArray[np.float64],npt.NDArray[np.float64],npt.NDArray[np.float64],npt.NDArray[np.float64]]: ...
    @property
    def jets_area(self) -> npt.NDArray[np.float64]: ...
    @property
    def subtracted_info(self) -> Optional[Tuple[Tuple[npt.NDArray[np.float64],npt.NDArray[np.float64],npt.NDArray[np.float64],npt.NDArray[np.float64]],npt.NDArray[np.int64]]]: ...

class OutputWrapperFloat:
    def __init__(self, *args, **kwargs) -> None: ...  # type: ignore
    @property
    def constituent_indices(self) -> List[List[int]]: ...
    @property
    def jets(self) -> Tuple[npt.NDArray[np.float32],npt.NDArray[np.float32],npt.NDArray[np.float32],npt.NDArray[np.float32]]: ...
    @property
    def jets_area(self) -> npt.NDArray[np.float32]: ...
    @property
    def subtracted_info(self) -> Optional[Tuple[Tuple[npt.NDArray[np.float32],npt.NDArray[np.float32],npt.NDArray[np.float32],npt.NDArray[np.float32]],npt.NDArray[np.int64]]]: ...

@overload
def find_jets(px: npt.NDArray[np.float32], py: npt.NDArray[np.float32], pz: npt.NDArray[np.float32], E: npt.NDArray[np.float32], background_px: npt.NDArray[np.float32], background_py: npt.NDArray[np.float32], background_pz: npt.NDArray[np.float32], background_E: npt.NDArray[np.float32], jet_R: float, jet_algorithm: str, area_settings: AreaSettings, eta_range: Tuple[float,float] = ..., min_jet_pt: float = ..., background_subtraction: bool = ..., constituent_subtraction: Optional[ConstituentSubtractionSettings] = ...) -> OutputWrapperFloat: ...  # type: ignore
@overload
def find_jets(px: npt.NDArray[np.float64], py: npt.NDArray[np.float64], pz: npt.NDArray[np.float64], E: npt.NDArray[np.float64], background_px: npt.NDArray[np.float64], background_py: npt.NDArray[np.float64], background_pz: npt.NDArray[np.float64], background_E: npt.NDArray[np.float64], jet_R: float, jet_algorithm: str, area_settings: AreaSettings, eta_range: Tuple[float,float] = ..., min_jet_pt: float = ..., background_subtraction: bool = ..., constituent_subtraction: Optional[ConstituentSubtractionSettings] = ...) -> OutputWrapperDouble: ...
@overload
def recluster_jet(px: npt.NDArray[np.float32], py: npt.NDArray[np.float32], pz: npt.NDArray[np.float32], E: npt.NDArray[np.float32], jet_R: float = ..., jet_algorithm: str = ..., area_settings: Optional[AreaSettings] = ..., eta_range: Tuple[float,float] = ..., store_recursive_splittings: bool = ...) -> JetSubstructureSplittings: ...
@overload
def recluster_jet(px: npt.NDArray[np.float64], py: npt.NDArray[np.float64], pz: npt.NDArray[np.float64], E: npt.NDArray[np.float64], jet_R: float = ..., jet_algorithm: str = ..., area_settings: Optional[AreaSettings] = ..., eta_range: Tuple[float,float] = ..., store_recursive_splittings: bool = ...) -> JetSubstructureSplittings: ...

# ALICE
# Fast sim
class TrackingEfficiencyEventActivity:
    central_00_10: ClassVar[TrackingEfficiencyEventActivity] = ...
    inclusive: ClassVar[TrackingEfficiencyEventActivity] = ...
    invalid: ClassVar[TrackingEfficiencyEventActivity] = ...
    mid_central_10_30: ClassVar[TrackingEfficiencyEventActivity] = ...
    peripheral_50_90: ClassVar[TrackingEfficiencyEventActivity] = ...
    semi_central_30_50: ClassVar[TrackingEfficiencyEventActivity] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TrackingEfficiencyPeriod:
    LHC11a: ClassVar[TrackingEfficiencyPeriod] = ...
    LHC11h: ClassVar[TrackingEfficiencyPeriod] = ...
    LHC15o: ClassVar[TrackingEfficiencyPeriod] = ...
    LHC18qr: ClassVar[TrackingEfficiencyPeriod] = ...
    disabled: ClassVar[TrackingEfficiencyPeriod] = ...
    pA: ClassVar[TrackingEfficiencyPeriod] = ...
    pp: ClassVar[TrackingEfficiencyPeriod] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def fast_sim_tracking_efficiency(track_pt: npt.NDArray[np.float64], track_eta: npt.NDArray[np.float64], event_activity: TrackingEfficiencyEventActivity, period: TrackingEfficiencyPeriod) -> object: ...
def find_event_activity(value: float) -> TrackingEfficiencyEventActivity: ...